Задания по Algorithm.LCA.C/Algorithm.LCA.C++
====
Algorithm.LCA.C tasks
==
## task1 - таблица умножения    

- Пользователь вводит число ```N```
- Программа генерирует в памяти таблицу умножения чисел от ```1``` до ```N```
- Пользователь вводит координаты "окна" в таблице, которое следует вывести на печать: 

 ```(1, 1) ≤ (x1, y1) ≤ (x2, y2) ≤ (N, N) ```
- Если вместо ```x1``` пользователь ввёл ```0``` - программа должна завершить выполнение и освободить выделенную память
- Проверка выполняется автоматически, на консоль не надо выводить ничего лишнего

### [Решение](task1/main.c)


task2 - Реализовать телефонную книжку
-
*   Структура включает в себя поля - `id`, `name`, `number`
*   Все данные хранятся в файле, имя файла передается аргументом командной строки
*   Все изменения должны должны сохраниться при обрывании программы (`SIGINT`, `ESC`)
*   При неправильном запросе должно выводиться сообщение об ошибке 
*   Cтруктура поддерживает функции
  *   `create [name] [number]` - создает контакт с заданным номером и именем.
  *   `find [name]` - ищет контакт по имени и возвращает `id`
 *   `find [number]` - ищет контакт по номеру и возвращает `id`
 *   `change [id] name [name]` - изменяет имя контакта, соответсвующего заданному `id`
 *   `change [id] number [number]` - изменяет номер контакта, соответсвующего заданному `id`
 *   `delete [id]` - удаляет контакт, соответсвующий заданному `id`
*  Ограничения:
    * Корректное имя состоит только из символов латинского алфавита в обоих регистрах
    * Поиск производится по подстроке имени без учета регистра
    * Корректный телефон содержит цифры, произвольное количество дефисов, не идущих подряд, не более одной пары круглых скобок и может начинаться с плюса.
    * Поиск по номеру учитывает только цифры и производится по полному соответствию
    * Длина имени и телефона не ограничена, однако суммарный размер записной книжки помещается в оперативную память 

    ### [Решение](task2/main.c)
    
    
Algorithm.LCA.C++ tasks
==
task3 - Реализовать библиотеку rational, реализующую работу с дробями
-
  *   Заголовочный файл `rational.h`
  *   Библиотека `librational.so` либо `librational.a`
  *   Конструктор `rational(int num)` - от целого числа;
  *   Конструктор `rational(int num, int denom)` - от числителя и знаменателя
  *   `int rational::getNum()` const - возвращает числитель
  *   `int rational::getDenom()` const - возвращает знаменатель
  *   перегрузка арифметичских операторов:
    * `rational const operator +(rational const &a) const`
    * `rational const operator -(rational const &b) const`
    * `rational const operator *(rational const &c) const`
    * `rational const operator /(rational const &d) const`
    
   ### [Решение](task3)


task4 - format, реализующую безопасный аналог sprintf
-
*   `#include<string>`
*   `#include <stdexcept>`
*   `template<typename... Args>`
*   `std::string format(std::string const & fmt, Args… args)`
*   Требования:
    * Заголовочный файл `format.h`
    * Библиотека `libformat.so` либо `libformat.a`
    * Формат - как у `sprintf`
    * В случае отсутствия аргумента кидается исключение `std::out_of_range`
    * Если `const char * == nullptr`, вместо него выводится `“<null>”`
    * `std::string` обрабатывается так же, как const `char *`
    * Если литерал формата не соответсвует типу аргумента - кидается исключение `std::invalid_argument`
    
    ### [Решение](task4)
    
task5 - Доработка format для поддержки автоопределения типа и указателей
-
*   Усовершенствовать `format`, добавив формат выводa `%@`, который: 
  * Если аргумент - `nullptr_t` – выводит `nullptr`
  * Если аргумент указатель, и его значение равно 0 – выводит `nulltpr<имя_типа>`
  * Если аргумент указатель, и его значение не равно 0 - выводит `ptr<имя_типа>`(вывод как для `%@`)
  * Если аргумент массив известной размерности – выводит элементы массива через запятую в `[]` 
  * Если аргумент может быть преобразован к `std::string` – выводит результат такого преобразования
  * Если ни одно преобразование невозможно – кидается исключение `std::invalid_argument`	

### [Решение](task5)
    
task6 - Класс lazy_string для работы со строками реализующий copy-on-write
---
*   Класс `lazy_string`, реализующий copy-on-write 
  * Конструируется от `std::string`
  * Приводится к `std::string` 
  * Имеет `size`, `length`, `at`, `operator[]` аналогично `std::string`
  * Имеет операторы ввода и вывода в поток (`<<`, `>>`)
  * Имеет `substr`, причем при взятии подстроки копирования не происходит

 ### [Решение](task6)
    
task7 - Доработка класса lazy_string для безопасной работы в многопоточном приложении
-
*  Доработать `lazy_string` для обеспечения безопасной работы из нескольких потоков
     

